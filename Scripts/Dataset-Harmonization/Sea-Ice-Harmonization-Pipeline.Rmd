---
title: "Sea Ice Harmonization Pipeline"
author: "Michael Wethington"
date: "2024-06-28"
output: html_document
---

# Introduction

This tutorial demonstrates how to harmonize two different raster datasets, apply an Artificial Neural Network (ANN) model to predict values, and visualize the results using the `terra`, `nnet`, and `tidymodels` packages in R. The example uses sea ice concentration data from two sources: AMSR-Unified 12.5 km and NSIDC 25 km.

## Overview and Objective

The primary objective of this script is to harmonize and compare sea ice concentration datasets from two different sources, AMSR-Unified 12.5 km and NSIDC 25 km. The script achieves this by performing the following steps:

1. **Load Necessary Libraries**: Import the required R libraries for handling raster data and performing data analysis.
2. **Load Raster Datasets**: Load the sea ice concentration datasets from AMSR-Unified and NSIDC.
3. **Verify and Align Extents and Origins**: Ensure that the spatial extents and origins of the two datasets are aligned to enable direct comparison.
4. **Define and Crop to Intersecting Extent**: Crop both datasets to a common intersecting spatial extent to ensure that they cover the same area.
5. **Resample NSIDC Dataset**: Resample the NSIDC dataset to match the 12.5 km resolution of the AMSR dataset using bilinear interpolation.
6. **Normalize Raster Values**: Normalize the values of both datasets to a 0-1 range for consistent analysis.
7. **Extract Common Dates and Subset Data**: Identify common dates between the two datasets and subset the data to these overlapping periods.
8. **Build and Train ANN Model**: Construct and train an ANN model to analyze the relationship between the AMSR and NSIDC datasets, tuning hyperparameters using grid search.
9. **Apply ANN Model to Raster Stack**: Apply the trained ANN model to predict values in the raster stack, ensuring predictions are clamped between 0 and 1.
10. **Visualize Results**: Plot the original and processed raster layers side by side to visually assess the results.
11. **Model Assessment Using `tidymodels`**: Evaluate the performance of the ANN model using the `tidymodels` package.


```{r}

# Load necessary libraries
if (!require(terra)) install.packages('terra')
if (!require(dplyr)) install.packages('dplyr')
if (!require(reshape2)) install.packages('reshape2')
if (!require(tidyr)) install.packages('tidyr')
if (!require(nnet)) install.packages('nnet')
if (!require(tidymodels)) install.packages('tidymodels')

library(terra)
library(dplyr)
library(reshape2)
library(tidyr)
library(nnet)
library(foreach)
library(doParallel)
library(yardstick)
library(patchwork)  # For combining plots


```


## Train/TestDataset Normalization and Alignment


```{r include=FALSE}

# Function to normalize raster values to a 0-1 range
normalize_raster <- function(r) {
  r_min <- global(r, min, na.rm = TRUE)[[1]]
  r_max <- global(r, max, na.rm = TRUE)[[1]]
  
  if (r_min >= 0 && r_max <= 1) {
    message("Raster values are already within the 0-1 range.")
    return(r)
  } else if (is.finite(r_min) && is.finite(r_max)) {
    normalized_raster <- (r - r_min) / (r_max - r_min)
    return(normalized_raster)
  } else {
    warning("Raster contains only NA values or min/max are not finite.")
    return(r)
  }
}

# Load the AMSR-Unified 12.5 km dataset
print("Loading AMSR-Unified 12.5 km dataset...")
amsr_12km <- tryCatch({
  rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/AMSR-Unified_12km/stack/substack/AMSR_12km_Full_Study_Area.nc")
}, error = function(e) {
  stop("Error loading AMSR-Unified dataset: ", e)
})

# Load the NSIDC 25 km dataset (full timeline from 1979 to 2024)
print("Loading NSIDC 25 km dataset...")
nsidc_25km <- tryCatch({
  rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/25km_Sea-Ice-Index/stack/substack/NSIDC_25km_Full_Study_Area.nc")
}, error = function(e) {
  stop("Error loading NSIDC dataset: ", e)
})

# Verify extents
print("Verifying extents...")
ext_amsr <- ext(amsr_12km)
ext_nsidc <- ext(nsidc_25km)

print(ext_amsr)
print(ext_nsidc)

# Check origins
print("Checking origins...")
origin_amsr <- origin(amsr_12km)
origin_nsidc <- origin(nsidc_25km)

print(origin_amsr)
print(origin_nsidc)

# Align the origin of the NSIDC raster to match the AMSR raster
print("Aligning NSIDC raster to AMSR origin...")
nsidc_aligned <- shift(nsidc_25km, dx = origin_amsr[1] - origin_nsidc[1], dy = origin_amsr[2] - origin_nsidc[2])

# Verify origins again
print("Verifying aligned origins...")
origin_nsidc_aligned <- origin(nsidc_aligned)
print(origin_nsidc_aligned)

# Define the intersecting extent with ymin rounded down to 174999
print("Defining intersecting extent...")
intersection_extent <- ext(
  max(ext_amsr$xmin, ext(nsidc_aligned)$xmin),
  min(ext_amsr$xmax, ext(nsidc_aligned)$xmax),
  174999,
  min(ext_amsr$ymax, ext(nsidc_aligned)$ymax)
)

print(intersection_extent)

# Crop both datasets to the intersecting extent
print("Cropping datasets to intersecting extent...")
amsr_cropped <- crop(amsr_12km, intersection_extent)
nsidc_cropped <- crop(nsidc_aligned, intersection_extent)



# Verify cropped extents
print("Verifying cropped extents...")
ext_amsr_cropped <- ext(amsr_cropped)
ext_nsidc_cropped <- ext(nsidc_cropped)

print(ext_amsr_cropped)
print(ext_nsidc_cropped)

# Resample the cropped NSIDC dataset to 12.5 km resolution using bilinear interpolation
print("Resampling NSIDC dataset to 12.5 km resolution...")
# nsidc_resampled_to_12_5km <- resample(nsidc_cropped, amsr_cropped, method = "bilinear")

# Normalize each layer individually and then combine
print("Normalizing AMSR raster values...")
amsr_normalized <- rast(lapply(1:nlyr(amsr_cropped), function(i) {
  print(paste("Normalizing AMSR layer", i))
  normalize_raster(amsr_cropped[[i]])
}))

print("Normalizing NSIDC raster values...")
nsidc_normalized <- rast(lapply(1:nlyr(nsidc_cropped), function(i) {
  print(paste("Normalizing NSIDC layer", i))
  normalize_raster(nsidc_cropped[[i]])
}))


nsidc_cropped <- nsidc_cropped / 100


# print("Normalizing NSIDC raster values...")
# nsidc_normalized <- rast(lapply(1:nlyr(nsidc_resampled_to_12_5km), function(i) {
#   print(paste("Normalizing NSIDC layer", i))
#   normalize_raster(nsidc_resampled_to_12_5km[[i]])
# }))

# Extract the time information
print("Extracting time information...")
amsr_dates <- time(amsr_normalized)
nsidc_dates <- time(nsidc_normalized)

# Ensure dates are in Date format and find common dates
print("Finding common dates...")
amsr_dates <- as.Date(amsr_dates)
nsidc_dates <- as.Date(nsidc_dates)
common_dates <- as.Date(intersect(amsr_dates, nsidc_dates))

# Find the indices of common dates in the AMSR and NSIDC datasets
print("Finding indices of common dates...")
amsr_indices <- which(amsr_dates %in% common_dates)
nsidc_indices <- which(nsidc_dates %in% common_dates)

# Subset the layers for the overlapping period
print("Subsetting layers for the overlapping period...")
amsr_overlap <- subset(amsr_normalized, amsr_indices)
nsidc_overlap <- subset(nsidc_normalized, nsidc_indices)

# Set the layer names to the corresponding dates
print("Setting layer names for AMSR and NSIDC overlap layers...")
names(amsr_overlap) <- common_dates
names(nsidc_overlap) <- common_dates

# Flatten the rasters to data frames
amsr_df <- as.data.frame(amsr_overlap, xy = TRUE)
nsidc_df <- as.data.frame(nsidc_overlap, xy = TRUE)

# Merge the data frames on the coordinates
merged_df <- merge(amsr_df, nsidc_df, by = c("x", "y"))

# Melt the dataframe to long format
merged_df_long <- melt(merged_df, id.vars = c("x", "y"))

# Separate the date and dataset type from the variable column
merged_df_long <- merged_df_long %>%
  mutate(date = as.Date(gsub("\\..*", "", variable), format = "%Y-%m-%d"),
         dataset = ifelse(grepl("\\.x$", variable), "amsr", "nsidc")) %>%
  select(-variable)

# Spread the dataframe to have separate columns for NSIDC and AMSR
normalized_sea_ice_concentration_df <- merged_df_long %>%
  pivot_wider(names_from = dataset, values_from = value)

# View the structure of the melted and spread dataframe
str(normalized_sea_ice_concentration_df)

# Ensure there are no missing values for the regression
normalized_sea_ice_concentration_df_clean <- normalized_sea_ice_concentration_df %>%
  filter(!is.na(nsidc) & !is.na(amsr))

# Set the output directory
output_dir <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023"
dir.create(output_dir, showWarnings = FALSE)

# Save the dataset
cat("Saving the prepared dataset...\n")
saveRDS(normalized_sea_ice_concentration_df_clean, file = file.path(output_dir, "normalized_sea_ice_concentration_df_clean.rds"))
cat("Prepared dataset saved.\n")

# Save the normalized AMSR and NSIDC raster stacks
cat("Saving the normalized AMSR raster stack...\n")
writeRaster(amsr_normalized, filename = file.path(output_dir, "amsr_normalized_2012-2023.tif"), overwrite = TRUE)
cat("AMSR normalized raster stack saved.\n")

cat("Saving the normalized NSIDC raster stack...\n")
writeRaster(nsidc_normalized, filename = file.path(output_dir, "nsidc_normalized_2012-2023.tif"), overwrite = TRUE)
cat("NSIDC normalized raster stack saved.\n")

# Verify saved datasets
cat("Verifying saved AMSR raster stack...\n")
amsr_normalized_loaded <- rast(file.path(output_dir, "amsr_normalized_2012-2023.tif"))
print(amsr_normalized_loaded)

cat("Verifying saved NSIDC raster stack...\n")
nsidc_normalized_loaded <- rast(file.path(output_dir, "nsidc_normalized_2012-2023.tif"))
print(nsidc_normalized_loaded)

cat("Verifying saved dataframe...\n")
normalized_sea_ice_concentration_df_clean_loaded <- readRDS(file.path(output_dir, "normalized_sea_ice_concentration_df_clean.rds"))
str(normalized_sea_ice_concentration_df_clean_loaded)

range(normalized_sea_ice_concentration_df_clean_loaded$amsr)
range(normalized_sea_ice_concentration_df_clean_loaded$nsidc)

```



**ANN Hyperparameter Tuning (nnet)**

```{r}


# Set the output directory
output_dir <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization"

# Load the saved dataset
cat("Loading the prepared dataset...\n")
merged_df_wide_clean <- readRDS(file = file.path(output_dir, "merged_df_wide_clean.rds"))

# Load the saved raster stack
cat("Loading the NSIDC resampled raster stack...\n")
nsidc_resampled_to_12_5km <- rast(file.path(output_dir, "nsidc_resampled_to_12_5km.tif"))



set.seed(123)  # For reproducibility
train_indices <- sample(1:nrow(merged_df_wide_clean), 0.8 * nrow(merged_df_wide_clean))
train_data <- merged_df_wide_clean[train_indices, ]
test_data <- merged_df_wide_clean[-train_indices, ]


# Set up parallel backend
numCores <- detectCores() - 5
cl <- makeCluster(numCores)
registerDoParallel(cl)

# Define a grid of hyperparameters to search
size_grid <- c(3, 5, 7, 10, 15)
decay_grid <- c(0.01, 0.001, 0.0001)
hyper_grid <- expand.grid(size = size_grid, decay = decay_grid)

# Function to train and evaluate the model
train_and_evaluate <- function(train_data, test_data, size, decay) {
  model <- nnet(amsr ~ nsidc, data = train_data, size = size, linout = TRUE, maxit = 500, decay = decay, trace = FALSE)
  predictions <- predict(model, newdata = test_data)
  mse <- mean((test_data$amsr - predictions)^2)
  return(mse)
}

# Perform grid search in parallel
grid_search_results <- foreach(i = 1:nrow(hyper_grid), .packages = 'nnet', .combine = rbind) %dopar% {
  size <- hyper_grid$size[i]
  decay <- hyper_grid$decay[i]
  mse <- train_and_evaluate(train_data, test_data, size, decay)
  data.frame(size = size, decay = decay, mse = mse)
}

# Stop the cluster
stopCluster(cl)

# Find the best hyperparameters
best_params <- grid_search_results[which.min(grid_search_results$mse), ]
cat("Best hyperparameters: size =", best_params$size, "decay =", best_params$decay, "with MSE =", best_params$mse, "\n")


# Set the output directory
output_dir <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization"

# Save the best hyperparameters and tuning results
cat("Saving the best hyperparameters and tuning results...\n")
saveRDS(best_params, file = file.path(output_dir, "best_hyperparameters.rds"))
saveRDS(grid_search_results, file = file.path(output_dir, "hyperparameter_tuning_results.rds"))
cat("Best hyperparameters and tuning results saved.\n")

```



**Train NNET model**

```{r}


# Load the prepared dataset
cat("Loading the prepared dataset...\n")
normalized_sea_ice_concentration_df_clean <- readRDS("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023/normalized_sea_ice_concentration_df_clean.rds")

# Load the saved raster stack
cat("Loading the NSIDC resampled raster stack...\n")
nsidc_resampled_to_12_5km <- rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023/nsidc_normalized_2012-2023.tif")

# Split into training and test sets
set.seed(123)  # For reproducibility
train_indices <- sample(1:nrow(normalized_sea_ice_concentration_df_clean), 0.8 * nrow(normalized_sea_ice_concentration_df_clean))
train_data <- normalized_sea_ice_concentration_df_clean[train_indices, ]
test_data <- normalized_sea_ice_concentration_df_clean[-train_indices, ]

# Train the final ANN model with the best hyperparameters
cat("Training the final ANN model with best hyperparameters...\n")
start_time <- Sys.time()
ann_model <- nnet(amsr ~ nsidc, data = train_data, size = 7, linout = TRUE, decay = 0.001, maxit = 1500, trace = TRUE)
end_time <- Sys.time()
cat("Final ANN training completed in", difftime(end_time, start_time, units = "secs"), "seconds.\n")

# Save the final trained ANN model
cat("Saving the final ANN model...\n")
saveRDS(ann_model, file = "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023/final_ann_model_1500-iterations.rds")
cat("Final ANN model saved.\n")

```


##Deploy ANN across the Alligned NSIDC Stack (1979-2023)

**Deploy the ANN**

```{r}

library(terra)
library(nnet)
library(dplyr)


# Load the trained ANN model
cat("Loading the trained ANN model...\n")
ann_model <- readRDS("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023/final_ann_model_1500-iterations.rds")

# Load the NSIDC raster stack and extract the time information
cat("Loading the NSIDC raster stack...\n")
nsidc_stack <- rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023/nsidc_normalized_2012-2023.tif")
original_dates <- time(nsidc_stack)  # Extracting time before any processing


# Define the prediction function
predict_harmonized_values <- function(x) {
  df_input <- data.frame(nsidc = x)
  predicted_values <- predict(ann_model, df_input)
  return(predicted_values)
}

# Apply the ANN model to the NSIDC stack
cat("Applying the ANN model to the NSIDC layers...\n")
harmonized_stack <- app(nsidc_stack, predict_harmonized_values)

time(harmonized_stack) <- original_dates


# Set values above 1 to 1
# harmonized_stack <- ifel(harmonized_stack > 1, 1, harmonized_stack)
# harmonized_stack <- ifel(harmonized_stack < 1, 0, harmonized_stack)



# Plot the first layer for verification
par(mfrow = c(1, 2))  # Set up the plotting area to have 1 row and 2 columns
plot(nsidc_stack[[1]], colNA = "red", main = "NSIDC 25km")
plot(harmonized_stack[[1]], colNA = "red", main = "NSIDC 12.5 km Harmonized")

# Set the output directory
output_dir <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/complete-harmonized-dataset"
# dir.create(output_dir, showWarnings = FALSE)

# # Save the harmonized NSIDC raster stack
# cat("Saving the Harmonized NSIDC raster stack...\n")
writeRaster(harmonized_stack, filename = file.path(output_dir, "nsidc_12_5km_harmonized_1979-2023.tif"), overwrite = TRUE)
# cat("Harmonized NSIDC raster stack saved.\n")



```




## Create Overlapping subsets of data in order to compare all 3

```{r}


# Load necessary libraries
library(terra)

# Define file paths
amsr_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023/amsr_normalized_2012-2023.tif"
nsidc_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023/nsidc_normalized_2012-2023.tif"
nsidc_harmonized_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/complete-harmonized-dataset/nsidc_12_5km_harmonized_1979-2023.tif"

# Load datasets
amsr_stack <- rast(amsr_path)
nsidc_stack <- rast(nsidc_path)
nsidc_harmonized_stack <- rast(nsidc_harmonized_path)

# Extract the date information from the raster metadata
amsr_dates <- as.Date(terra::time(amsr_stack), origin = "1970-01-01")
nsidc_dates <- as.Date(terra::time(nsidc_stack), origin = "1970-01-01")
nsidc_harmonized_dates <- as.Date(terra::time(nsidc_harmonized_stack), origin = "1970-01-01")

# Find common dates between AMSR and NSIDC Harmonized datasets
common_dates <- as.Date(intersect(amsr_dates, nsidc_harmonized_dates))

# Find indices for common dates in the NSIDC Harmonized stack
nsidc_harmonized_indices <- which(nsidc_harmonized_dates %in% common_dates)

# Subset the NSIDC Harmonized stack for the overlapping period
cat("Subsetting NSIDC Harmonized stack for the overlapping period...\n")
nsidc_harmonized_overlap <- subset(nsidc_harmonized_stack, nsidc_harmonized_indices)

# Find indices for common dates in the NSIDC stack
nsidc_indices <- which(nsidc_dates %in% common_dates)

# Subset the NSIDC stack for the overlapping period
cat("Subsetting NSIDC stack for the overlapping period...\n")
nsidc_overlap <- subset(nsidc_stack, nsidc_indices)

# Define the target directory for exporting
output_dir <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison"

# Export the subsetted rasters
cat("Exporting subsetted rasters...\n")
writeRaster(nsidc_harmonized_overlap, filename = file.path(output_dir, "nsidc_harmonized_common_dates.tif"), overwrite = TRUE)
writeRaster(nsidc_overlap, filename = file.path(output_dir, "nsidc_common_dates.tif"), overwrite = TRUE)
writeRaster(nsidc_overlap, filename = file.path(amsr_stack, "amsr_common_dates.tif"), overwrite = TRUE)

# Print the structure of each subsetted dataset
print("AMSR 12.5 km Dataset Structure:")
print(list(dimensions = dim(amsr_stack), extent = ext(amsr_stack), crs = crs(amsr_stack), nlyr = nlyr(amsr_stack), resolution = res(amsr_stack)))

print("NSIDC 25 km Overlap Dataset Structure:")
print(list(dimensions = dim(nsidc_overlap), extent = ext(nsidc_overlap), crs = crs(nsidc_overlap), nlyr = nlyr(nsidc_overlap), resolution = res(nsidc_overlap)))

print("NSIDC Harmonized 12.5 km Overlap Dataset Structure:")
print(list(dimensions = dim(nsidc_harmonized_overlap), extent = ext(nsidc_harmonized_overlap), crs = crs(nsidc_harmonized_overlap), nlyr = nlyr(nsidc_harmonized_overlap), resolution = res(nsidc_harmonized_overlap)))


```



## Assess Model Performance by comparing overlapping period


**Ensure all datasets are comparable**

```{r}
# Load necessary libraries
library(terra)
library(dplyr)
library(ggplot2)
library(lubridate)

# Define file paths for the raster datasets
amsr_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/amsr_common_dates.tif"
nsidc_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_common_dates.tif"
nsidc_harmonized_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_harmonized_common_dates.tif"

# Load the raster datasets
amsr_stack <- rast(amsr_path)
nsidc_stack <- rast(nsidc_path)
nsidc_harmonized_stack <- rast(nsidc_harmonized_path)

# Extract the date information from the raster metadata
amsr_dates <- as.Date(terra::time(amsr_stack), origin = "1970-01-01")
nsidc_dates <- as.Date(terra::time(nsidc_stack), origin = "1970-01-01")
nsidc_harmonized_dates <- as.Date(terra::time(nsidc_harmonized_stack), origin = "1970-01-01")


# Ensure the extents are the same
if (!all.equal(ext(amsr_stack), ext(nsidc_stack)) || 
    !all.equal(ext(amsr_stack), ext(nsidc_harmonized_stack))) {
  stop("The extents of the raster stacks do not match.")
}

# Ensure the date ranges are the same
if (!(all(range(amsr_dates)[1] == range(nsidc_dates)[1], range(amsr_dates)[1] == range(nsidc_harmonized_dates)[1]) &&
      all(range(amsr_dates)[2] == range(nsidc_dates)[2], range(amsr_dates)[2] == range(nsidc_harmonized_dates)[2]))) {
  stop("The date ranges of the raster stacks do not match.")
}

# Ensure the included dates are exactly the same
if (!(all(amsr_dates == nsidc_dates) && all(amsr_dates == nsidc_harmonized_dates))) {
  stop("The dates included in the raster stacks do not match.")
}

cat("All checks passed: Extents, date ranges, and exact dates are the same.\n")


```




1. First Script: Visualizing Overlapping Datasets and Calculating Annual Statistics
Objective:

    The primary goal of this script is to visualize the overlapping sea ice datasets (AMSR, NSIDC, NSIDC Harmonized) and compute summary statistics (mean, median, maximum, and minimum) for sea ice extent over the years.

Key Features:

    Data Processing:
        Loads three raster datasets: AMSR, NSIDC, and NSIDC Harmonized.
        Extracts date information from the raster metadata.
        Processes each dataset by calculating sea ice extent for every layer (time step) based on the condition that sea ice concentration >= 0.15.
        Computes the total sea ice area in square kilometers by multiplying valid ice cells by the cell area.
    Annual Statistics:
        For each year, computes four key statistics for each dataset: mean, median, max, and min sea ice extent.
        Groups the data by year and dataset source (AMSR, NSIDC, NSIDC Harmonized).
    Visualization:
        Generates four plots (mean, median, max, min sea ice extent), each showing the sea ice extent over the years for the three datasets.
        Uses color-coded lines for each dataset (AMSR in blue, NSIDC in orange, NSIDC Harmonized in green).
        Combines the four plots into a single grid using patchwork.

Output:

    A 2x2 grid showing the mean, median, max, and min annual sea ice extent for AMSR, NSIDC, and NSIDC Harmonized datasets.
    
    


## Visualize the overlapping datasets 
```{r}

# Load necessary libraries
library(terra)
library(dplyr)
library(lubridate)
library(ggplot2)
library(patchwork)  # For combining plots

# Define file paths for the raster datasets
amsr_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/amsr_common_dates.tif"
nsidc_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_common_dates.tif"
nsidc_harmonized_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_harmonized_common_dates.tif"

# Load the raster datasets
amsr_stack <- rast(amsr_path)
nsidc_stack <- rast(nsidc_path)
nsidc_harmonized_stack <- rast(nsidc_harmonized_path)

# Extract the date information from the raster metadata
amsr_dates <- as.Date(terra::time(amsr_stack), origin = "1970-01-01")
nsidc_dates <- as.Date(terra::time(nsidc_stack), origin = "1970-01-01")
nsidc_harmonized_dates <- as.Date(terra::time(nsidc_harmonized_stack), origin = "1970-01-01")

# Calculate the area of one cell in square kilometers
cell_area_sq_km <- prod(res(amsr_stack)) / 1e6

# Function to calculate sea ice extent statistics
calculate_layer_stats <- function(layer, date, cell_area_sq_km) {
  valid_ice_cells <- global(layer, fun = function(x) sum(x >= 0.15, na.rm = TRUE))
  total_ice_area_sq_km <- (valid_ice_cells * cell_area_sq_km)  # Total ice area in square kilometers
  return(data.frame(ice_extent_km = total_ice_area_sq_km, date = date))
}

# Function to process the raster data and calculate statistics
process_data <- function(raster, dates, cell_area_sq_km) {
  sea_ice_stats <- lapply(1:nlyr(raster), function(i) {
    calculate_layer_stats(raster[[i]], dates[i], cell_area_sq_km)
  })
  sea_ice_stats_df <- do.call(rbind, sea_ice_stats) %>%
    mutate(Date = as.Date(date), Year = year(Date), Month = month(Date, label = TRUE, abbr = TRUE))
  return(sea_ice_stats_df)
}

# Process each raster stack
amsr_stats <- process_data(amsr_stack, amsr_dates, cell_area_sq_km)
nsidc_stats <- process_data(nsidc_stack, nsidc_dates, cell_area_sq_km)
nsidc_harmonized_stats <- process_data(nsidc_harmonized_stack, nsidc_harmonized_dates, cell_area_sq_km)

# Ensure consistent column names for all datasets before merging
amsr_stats <- process_data(amsr_stack, amsr_dates, cell_area_sq_km) %>%
  mutate(Source = "AMSR") %>%
  rename(ice_extent_km = global)  # Assuming 'global' is the sea ice extent column

nsidc_stats <- process_data(nsidc_stack, nsidc_dates, cell_area_sq_km) %>%
  mutate(Source = "NSIDC") %>%
  rename(ice_extent_km = global)

nsidc_harmonized_stats <- process_data(nsidc_harmonized_stack, nsidc_harmonized_dates, cell_area_sq_km) %>%
  mutate(Source = "NSIDC_Harmonized") %>%
  rename(ice_extent_km = global)


# 
# # Calculate annual statistics
# stats_summary <- amsr_stats %>% 
#   full_join(nsidc_stats, by = "Year") %>% 
#   full_join(nsidc_harmonized_stats, by = "Year") %>% 
#   group_by(Year) %>%
#   summarise(mean_extent = mean(global, na.rm = TRUE),
#             median_extent = median(global, na.rm = TRUE),
#             max_extent = max(global, na.rm = TRUE),
#             min_extent = min(global, na.rm = TRUE))
# 
# # Calculate annual statistics using the correct data structure
# stats_summary <- bind_rows(amsr_stats, nsidc_stats, nsidc_harmonized_stats) %>%
#   group_by(Year, Source) %>%
#   summarise(
#     mean_extent = mean(global, na.rm = TRUE),
#     median_extent = median(global, na.rm = TRUE),
#     max_extent = max(global, na.rm = TRUE),
#     min_extent = min(global, na.rm = TRUE),
#     .groups = "drop"  # Drop grouping for further manipulations
#   )

# Calculate annual statistics using the correct data structure
stats_summary <- bind_rows(amsr_stats, nsidc_stats, nsidc_harmonized_stats) %>%
  group_by(Year, Source) %>%
  summarise(
    mean_extent = mean(ice_extent_km, na.rm = TRUE),
    median_extent = median(ice_extent_km, na.rm = TRUE),
    max_extent = max(ice_extent_km, na.rm = TRUE),
    min_extent = min(ice_extent_km, na.rm = TRUE),
    .groups = "drop"  # Drop grouping for further manipulations
  )

# Define color-blind friendly colors
line_colors <- c("AMSR" = "#377eb8", "NSIDC" = "#ff7f00", "NSIDC Harmonized" = "#4daf4a")


# Plotting each statistic with all sources on each plot
p_mean <- ggplot(stats_summary, aes(x = Year, y = mean_extent, color = Source)) +
  geom_line(size = 0.75) +
  scale_color_manual(values = line_colors) +
  labs(title = "Mean Annual Sea Ice Extent", y = "Mean Extent (sq km)")

p_median <- ggplot(stats_summary, aes(x = Year, y = median_extent, color = Source)) +
  geom_line(size = 0.75) +
  scale_color_manual(values = line_colors) +
  labs(title = "Median Annual Sea Ice Extent", y = "Median Extent (sq km)")

p_max <- ggplot(stats_summary, aes(x = Year, y = max_extent, color = Source)) +
  geom_line(size = 0.75) +
  scale_color_manual(values = line_colors) +
  labs(title = "Maximum Annual Sea Ice Extent", y = "Max Extent (sq km)")

p_min <- ggplot(stats_summary, aes(x = Year, y = min_extent, color = Source)) +
  geom_line(size = 0.75) +
  scale_color_manual(values = line_colors) +
  labs(title = "Minimum Annual Sea Ice Extent", y = "Min Extent (sq km)")

# Combine the plots into a grid
combined_plot <- (p_mean | p_median) / (p_max | p_min) + 
  plot_layout(guides = 'collect') +
  theme(legend.position = "right")

# Print the combined plot
print(combined_plot)

```


2. Calculating and Plotting Annual Differences Between Datasets
Objective:

    This script focuses on calculating the differences in sea ice extent between the NSIDC Harmonized dataset and the other two datasets (AMSR and NSIDC) over the years.

Key Features:

    Data Processing:
        Similar to the first script, it loads and processes three raster datasets (AMSR, NSIDC, NSIDC Harmonized) and calculates sea ice extent for each time step.

    Calculating Differences:
        After processing each dataset, the script calculates the difference between the sea ice extent values of the NSIDC Harmonized dataset and the AMSR and NSIDC datasets:
            Diff_AMSR = NSIDC_Harmonized - AMSR
            Diff_NSIDC = NSIDC_Harmonized - NSIDC

    Summary of Differences:
        Computes the mean and standard deviation of the differences for both AMSR and NSIDC comparisons, summarizing how well the harmonized dataset aligns with the original datasets.

    Visualization:
        Plots the difference in sea ice extent between NSIDC Harmonized vs. AMSR and NSIDC Harmonized vs. NSIDC over the years.
        Uses line plots to visualize the difference for each comparison, color-coded for clarity.
        Combines the two plots into a vertical grid using patchwork.

Output:

    A vertical 2-plot grid showing the annual differences in sea ice extent between NSIDC Harmonized vs. AMSR and NSIDC Harmonized vs. NSIDC, highlighting the variability in the differences.

```{r}

# Load necessary libraries
library(terra)
library(dplyr)
library(lubridate)
library(ggplot2)
library(patchwork)  # For combining plots

# Define file paths for the raster datasets
amsr_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/amsr_common_dates.tif"
nsidc_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_common_dates.tif"
nsidc_harmonized_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_harmonized_common_dates.tif"

# Load the raster datasets
amsr_stack <- rast(amsr_path)
nsidc_stack <- rast(nsidc_path)
nsidc_harmonized_stack <- rast(nsidc_harmonized_path)

# Extract the date information from the raster metadata
amsr_dates <- as.Date(terra::time(amsr_stack), origin = "1970-01-01")
nsidc_dates <- as.Date(terra::time(nsidc_stack), origin = "1970-01-01")
nsidc_harmonized_dates <- as.Date(terra::time(nsidc_harmonized_stack), origin = "1970-01-01")

# Calculate the area of one cell in square kilometers
cell_area_sq_km <- prod(res(amsr_stack)) / 1e6

# Function to calculate sea ice extent statistics
calculate_layer_stats <- function(layer, date, cell_area_sq_km) {
  valid_ice_cells <- global(layer, fun = function(x) sum(x >= 0.15, na.rm = TRUE))
  total_ice_area_sq_km <- (valid_ice_cells * cell_area_sq_km)  # Total ice area in square kilometers
  return(data.frame(ice_extent_km = total_ice_area_sq_km, date = date))
}

# Function to process the raster data and calculate statistics
process_data <- function(raster, dates, cell_area_sq_km) {
  sea_ice_stats <- lapply(1:nlyr(raster), function(i) {
    calculate_layer_stats(raster[[i]], dates[i], cell_area_sq_km)
  })
  sea_ice_stats_df <- do.call(rbind, sea_ice_stats) %>%
    mutate(Date = as.Date(date), Year = year(Date), Month = month(Date, label = TRUE, abbr = TRUE))
  return(sea_ice_stats_df)
}

# Process each raster stack
amsr_stats <- process_data(amsr_stack, amsr_dates, cell_area_sq_km) %>%
  mutate(Source = "AMSR")

nsidc_stats <- process_data(nsidc_stack, nsidc_dates, cell_area_sq_km) %>%
  mutate(Source = "NSIDC")

nsidc_harmonized_stats <- process_data(nsidc_harmonized_stack, nsidc_harmonized_dates, cell_area_sq_km) %>%
  mutate(Source = "NSIDC_Harmonized")

# Calculate differences between harmonized dataset and the other datasets
differences <- bind_rows(amsr_stats, nsidc_stats, nsidc_harmonized_stats) %>%
  spread(Source, ice_extent_km) %>%
  mutate(
    Diff_AMSR = NSIDC_Harmonized - AMSR,
    Diff_NSIDC = NSIDC_Harmonized - NSIDC
  )

# Summarize differences
summary_diff <- differences %>%
  summarise(
    Mean_Diff_AMSR = mean(Diff_AMSR, na.rm = TRUE),
    SD_Diff_AMSR = sd(Diff_AMSR, na.rm = TRUE),
    Mean_Diff_NSIDC = mean(Diff_NSIDC, na.rm = TRUE),
    SD_Diff_NSIDC = sd(Diff_NSIDC, na.rm = TRUE)
  )

print(summary_diff)

# Plot differences
p_diff_amsr <- ggplot(differences, aes(x = Year, y = Diff_AMSR)) +
  geom_line(color = "#377eb8") +
  labs(title = "Difference in Sea Ice Extent: NSIDC Harmonized vs AMSR", y = "Difference (sq km)", x = "Year")

p_diff_nsidc <- ggplot(differences, aes(x = Year, y = Diff_NSIDC)) +
  geom_line(color = "#ff7f00") +
  labs(title = "Difference in Sea Ice Extent: NSIDC Harmonized vs NSIDC", y = "Difference (sq km)", x = "Year")

# Combine the plots into a grid
combined_diff_plot <- p_diff_amsr / p_diff_nsidc + plot_layout(guides = 'collect') + theme(legend.position = "right")

# Print the combined plot
print(combined_diff_plot)


```



This script focuses on visualizing pixel-level differences between the AMSR, NSIDC (original), and NSIDC Harmonized datasets, using a black mask as a background for areas outside of the region of interest. Here’s a breakdown of what makes this script different from the others:

Key Features:

    Pixel-Level Differences:
        This script calculates pixel-level differences between two datasets (AMSR vs. NSIDC and AMSR vs. NSIDC Harmonized). This is done using the function calculate_pixel_diff_raster(), which computes the difference between corresponding layers of two datasets while retaining the direction of the difference.
        AMSR vs. NSIDC: The difference shows how much the sea ice concentration estimates differ between the AMSR and NSIDC datasets.
        AMSR vs. NSIDC Harmonized: The difference shows how well the harmonized dataset compares with AMSR at the pixel level.

    Black Mask for Background:
        A black mask is applied as the background for regions outside of the area of interest (i.e., masked regions). This is done by loading a raster mask (which has pre-defined masked areas) and plotting it first in black behind the sea ice data.
        The masked areas, represented in black, provide a visual distinction between regions with valid data and those without.

    Custom Diverging Color Scale:
        The script uses a diverging color scale (blue to white to orange) to represent pixel-level differences:
            Blue: Negative differences (AMSR estimates greater than the NSIDC/NSIDC Harmonized).
            White: Zero difference (perfect alignment between datasets).
            Orange: Positive differences (NSIDC/NSIDC Harmonized estimates are greater than AMSR).
        This color scale helps visually identify where and how much the datasets differ, both positively and negatively.

    Date-Based Comparison:
        The script selects three specific dates from the dataset (date1, date2, and date3) for comparison. The pixel-level differences are calculated and visualized for each of these dates.
        The user can adjust these dates to focus on different time periods within the datasets.

    Visualization:
        The script creates individual plots for the AMSR vs. NSIDC and AMSR vs. Harmonized comparisons for each selected date.
        These plots are then combined into a grid using patchwork, which displays all six plots (three dates × two comparisons) side by side for easy visual comparison.


**Visualize Pixel Level Difference**
```{r}
# Load necessary libraries
library(terra)
library(ggplot2)
library(patchwork)

# Load the raster black mask (we will color all masked areas black)
black_mask_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/Land_Mask/Black_Mask.tif"
black_mask <- rast(black_mask_path)

# Function to calculate the pixel-level difference (retain direction)
calculate_pixel_diff_raster <- function(layer1, layer2) {
  diff <- layer1 - layer2  # Calculate the difference (retain direction)
  return(diff)  # Return the difference as a SpatRaster object
}

# Select dates for the layers to be compared (adjust according to your needs)
date1 <- as.Date(amsr_dates[1])
date2 <- as.Date(amsr_dates[2])
date3 <- as.Date(amsr_dates[3])

# Calculate pixel-level differences for AMSR vs. NSIDC (original)
pixel_diff_amsr_nsidc_1 <- calculate_pixel_diff_raster(amsr_stack[[1]], nsidc_stack[[1]])
pixel_diff_amsr_nsidc_2 <- calculate_pixel_diff_raster(amsr_stack[[2]], nsidc_stack[[2]])
pixel_diff_amsr_nsidc_3 <- calculate_pixel_diff_raster(amsr_stack[[3]], nsidc_stack[[3]])

# Calculate pixel-level differences for AMSR vs. Harmonized
pixel_diff_amsr_harmonized_1 <- calculate_pixel_diff_raster(amsr_stack[[1]], nsidc_harmonized_stack[[1]])
pixel_diff_amsr_harmonized_2 <- calculate_pixel_diff_raster(amsr_stack[[2]], nsidc_harmonized_stack[[2]])
pixel_diff_amsr_harmonized_3 <- calculate_pixel_diff_raster(amsr_stack[[3]], nsidc_harmonized_stack[[3]])

# Convert the raster data to data frames for plotting
df_amsr_nsidc_1 <- as.data.frame(pixel_diff_amsr_nsidc_1, xy = TRUE)
df_amsr_nsidc_2 <- as.data.frame(pixel_diff_amsr_nsidc_2, xy = TRUE)
df_amsr_nsidc_3 <- as.data.frame(pixel_diff_amsr_nsidc_3, xy = TRUE)

df_amsr_harmonized_1 <- as.data.frame(pixel_diff_amsr_harmonized_1, xy = TRUE)
df_amsr_harmonized_2 <- as.data.frame(pixel_diff_amsr_harmonized_2, xy = TRUE)
df_amsr_harmonized_3 <- as.data.frame(pixel_diff_amsr_harmonized_3, xy = TRUE)

# Convert black mask to a data frame
df_black_mask <- as.data.frame(black_mask, xy = TRUE)

# Define custom diverging color scale
custom_colors <- scale_fill_gradient2(
  low = "steelblue",    # Negative differences (blue)
  mid = "white",        # Zero difference (white)
  high = "orange",      # Positive differences (orange)
  na.value = "black",   # NA values as black for background mask
  limits = c(-0.5, 0.5),  # Adjust the range as needed
  name = "Difference"
)

# Plot AMSR vs. NSIDC (original) pixel differences with black mask as background
plot_amsr_nsidc_1 <- ggplot() +
  geom_raster(data = df_black_mask, aes(x = x, y = y), fill = "black", na.rm = TRUE) +  # Plot black mask first (background)
  geom_raster(data = df_amsr_nsidc_1, aes(x = x, y = y, fill = df_amsr_nsidc_1[, 3])) +
  custom_colors +
  labs(title = paste("AMSR vs NSIDC (Original) - Date:", date1)) +
  theme_minimal()

plot_amsr_nsidc_2 <- ggplot() +
  geom_raster(data = df_black_mask, aes(x = x, y = y), fill = "black", na.rm = TRUE) +  # Plot black mask first (background)
  geom_raster(data = df_amsr_nsidc_2, aes(x = x, y = y, fill = df_amsr_nsidc_2[, 3])) +
  custom_colors +
  labs(title = paste("AMSR vs NSIDC (Original) - Date:", date2)) +
  theme_minimal()

plot_amsr_nsidc_3 <- ggplot() +
  geom_raster(data = df_black_mask, aes(x = x, y = y), fill = "black", na.rm = TRUE) +  # Plot black mask first (background)
  geom_raster(data = df_amsr_nsidc_3, aes(x = x, y = y, fill = df_amsr_nsidc_3[, 3])) +
  custom_colors +
  labs(title = paste("AMSR vs NSIDC (Original) - Date:", date3)) +
  theme_minimal()

# Plot AMSR vs. Harmonized pixel differences with black mask as background
plot_amsr_harmonized_1 <- ggplot() +
  geom_raster(data = df_black_mask, aes(x = x, y = y), fill = "black", na.rm = TRUE) +  # Plot black mask first (background)
  geom_raster(data = df_amsr_harmonized_1, aes(x = x, y = y, fill = df_amsr_harmonized_1[, 3])) +
  custom_colors +
  labs(title = paste("AMSR vs Harmonized - Date:", date1)) +
  theme_minimal()

plot_amsr_harmonized_2 <- ggplot() +
  geom_raster(data = df_black_mask, aes(x = x, y = y), fill = "black", na.rm = TRUE) +  # Plot black mask first (background)
  geom_raster(data = df_amsr_harmonized_2, aes(x = x, y = y, fill = df_amsr_harmonized_2[, 3])) +
  custom_colors +
  labs(title = paste("AMSR vs Harmonized - Date:", date2)) +
  theme_minimal()

plot_amsr_harmonized_3 <- ggplot() +
  geom_raster(data = df_black_mask, aes(x = x, y = y), fill = "black", na.rm = TRUE) +  # Plot black mask first (background)
  geom_raster(data = df_amsr_harmonized_3, aes(x = x, y = y, fill = df_amsr_harmonized_3[, 3])) +
  custom_colors +
  labs(title = paste("AMSR vs Harmonized - Date:", date3)) +
  theme_minimal()

# Combine the plots side by side for AMSR vs NSIDC and AMSR vs Harmonized comparisons
combined_plot <- (plot_amsr_nsidc_1 + plot_amsr_harmonized_1) / 
  (plot_amsr_nsidc_2 + plot_amsr_harmonized_2) / 
  (plot_amsr_nsidc_3 + plot_amsr_harmonized_3) +
  plot_layout(guides = 'collect')

# Print the combined plot
print(combined_plot)


```

**ANN Model Assessment**

```{r}

# Load the necessary libraries
library(terra)
library(nnet)
library(dplyr)
library(yardstick)

# Load the trained ANN model
cat("Loading the trained ANN model...\n")
ann_model <- readRDS("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023/final_ann_model_1500-iterations.rds")

# Load the train/test dataset
cat("Loading the prepared dataset...\n")
normalized_sea_ice_concentration_df_clean <- readRDS("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/normalized_rasters_2012-2023/normalized_sea_ice_concentration_df_clean.rds")

# Load the NSIDC raster stack
cat("Loading the NSIDC raster stack...\n")
nsidc_stack <- rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_common_dates.tif")

# Load the AMSR raster stack
cat("Loading the AMSR raster stack...\n")
amsr_stack <- rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/amsr_common_dates.tif")

# Extract the date information from the raster metadata
nsidc_dates <- as.Date(time(nsidc_stack), origin = "1970-01-01")
amsr_dates <- as.Date(time(amsr_stack), origin = "1970-01-01")

# Find common dates between the two datasets
common_dates <- as.Date(intersect(nsidc_dates, amsr_dates))

# Find indices for common dates in both stacks
nsidc_indices <- which(nsidc_dates %in% common_dates)
amsr_indices <- which(amsr_dates %in% common_dates)

# Subset the layers for the overlapping period
cat("Subsetting layers for the overlapping period...\n")
amsr_overlap <- subset(amsr_stack, amsr_indices)
nsidc_overlap <- subset(nsidc_stack, nsidc_indices)

# Set the layer names to the corresponding dates
cat("Setting layer names for AMSR and NSIDC overlap layers...\n")
names(amsr_overlap) <- common_dates
names(nsidc_overlap) <- common_dates


# Define the output file path
output_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/amsr_12_5km_harmonized_winter_2012-2023.tif"

# Export the updated harmonized_stack to the specified directory
writeRaster(amsr_overlap, output_path, overwrite = TRUE)

# Define the output file path
output_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_25km_harmonized_winter_2012-2023.tif"

# Export the updated harmonized_stack to the specified directory
writeRaster(nsidc_overlap, output_path, overwrite = TRUE)


# Define the prediction function
predict_harmonized_values <- function(x) {
  df_input <- data.frame(nsidc = x)
  predicted_values <- predict(ann_model, df_input)
  return(predicted_values)
}

# Harmonize the NSIDC stack
cat("Applying the ANN model to the NSIDC layers...\n")
harmonized_stack <- app(nsidc_overlap, predict_harmonized_values)


# Assuming 'nsidc_overlap' and 'harmonized_stack' are already loaded in your R session
# Extract the time information from nsidc_overlap
nsidc_dates <- time(nsidc_overlap)

# Assign these dates to harmonized_stack
time(harmonized_stack) <- nsidc_dates

# Verify the time assignment
print(time(harmonized_stack))

# Assuming 'harmonized_stack' has already been updated with the dates from 'nsidc_overlap' in your R session
# Define the output file path
output_path <- "D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_12_5km_harmonized_winter_2012-2023.tif"

# Export the updated harmonized_stack to the specified directory
writeRaster(harmonized_stack, output_path, overwrite = TRUE)

cat("Harmonized stack with dates has been successfully exported to:", output_path, "\n")

# Compute statistical metrics
compute_metrics <- function(actual, predicted) {
  actual_values <- values(actual)
  predicted_values <- values(predicted)
  # Remove NA values for accurate comparison
  valid_indices <- !is.na(actual_values) & !is.na(predicted_values)
  actual_values <- actual_values[valid_indices]
  predicted_values <- predicted_values[valid_indices]
  
  mae <- yardstick::mae_vec(actual_values, predicted_values)
  rmse <- yardstick::rmse_vec(actual_values, predicted_values)
  r2 <- cor(actual_values, predicted_values)^2
  
  return(list(MAE = mae, RMSE = rmse, R2 = r2))
}

# Split into training and test sets
set.seed(123)  # For reproducibility
train_indices <- sample(1:nrow(normalized_sea_ice_concentration_df_clean), 0.8 * nrow(normalized_sea_ice_concentration_df_clean))
train_data <- normalized_sea_ice_concentration_df_clean[train_indices, ]
test_data <- normalized_sea_ice_concentration_df_clean[-train_indices, ]

# Apply metrics to each layer
metrics_list <- lapply(1:nlyr(amsr_overlap), function(i) {
  actual <- amsr_overlap[[i]]
  predicted <- harmonized_stack[[i]]
  compute_metrics(actual, predicted)
})

# Print out metrics for each layer
for (i in 1:length(metrics_list)) {
  cat("Layer", i, ":\n")
  print(metrics_list[[i]])
}

# Extract individual metric values and calculate the averages
mae_values <- sapply(metrics_list, function(x) x$MAE)
rmse_values <- sapply(metrics_list, function(x) x$RMSE)
r2_values <- sapply(metrics_list, function(x) x$R2)

average_mae <- mean(mae_values, na.rm = TRUE)
average_rmse <- mean(rmse_values, na.rm = TRUE)
average_r2 <- mean(r2_values, na.rm = TRUE)

# Print out average metrics
cat("Average MAE:", average_mae, "\n")
cat("Average RMSE:", average_rmse, "\n")
cat("Average R2:", average_r2, "\n")

# Evaluate the model using yardstick on the test dataset
cat("Evaluating the model on the test dataset...\n")
test_data <- test_data %>%
  mutate(predictions = as.numeric(predict(ann_model, newdata = test_data)))

mae_result <- yardstick::mae(test_data, truth = amsr, estimate = predictions, na_rm = TRUE)
rmse_result <- yardstick::rmse(test_data, truth = amsr, estimate = predictions, na_rm = TRUE)
rsq_result <- yardstick::rsq(test_data, truth = amsr, estimate = predictions, na_rm = TRUE)
smape_result <- yardstick::smape(test_data, truth = amsr, estimate = predictions, na_rm = TRUE)
mase_result <- yardstick::mase(test_data, truth = amsr, estimate = predictions, na_rm = TRUE)
ccc_result <- yardstick::ccc(test_data, truth = amsr, estimate = predictions, na_rm = TRUE)
huber_loss_result <- yardstick::huber_loss(test_data, truth = amsr, estimate = predictions, na_rm = TRUE)
rpiq_result <- yardstick::rpiq(test_data, truth = amsr, estimate = predictions, na_rm = TRUE)
rpd_result <- yardstick::rpd(test_data, truth = amsr, estimate = predictions, na_rm = TRUE)

# Print yardstick metrics
cat("Test Data Metrics:\n")
cat("MAE:", mae_result$.estimate, "\n")
cat("RMSE:", rmse_result$.estimate, "\n")
cat("R2:", rsq_result$.estimate, "\n")
cat("SMAPE:", smape_result$.estimate, "\n")
cat("MASE:", mase_result$.estimate, "\n")
cat("CCC:", ccc_result$.estimate, "\n")
cat("Huber Loss:", huber_loss_result$.estimate, "\n")
cat("RPIQ:", rpiq_result$.estimate, "\n")
cat("RPD:", rpd_result$.estimate, "\n")


nsidc_dates <- terra::time(harmonized_stack) <- amsr_dates

terra::time(harmonized_stack) <- amsr_dates

length(amsr_dates)

# Optionally, plot the first layer of each stack for verification
par(mfrow = c(1, 3))  # Set up the plotting area to have 1 row and 3 columns
plot(nsidc_overlap[[1]], colNA = "red", main = "NSIDC 25km")
plot(harmonized_stack[[1]], colNA = "red", main = "NSIDC 12.5 km Harmonized")
plot(amsr_overlap[[1]], colNA = "red", main = "AMSR Unified 12.5 km")


```


**ANN Model assesment (sans harmonization training)**
```{r}
# Load the necessary libraries
library(terra)
library(dplyr)
library(yardstick)
library(ggplot2)
library(hexbin)
library(viridis)

# Load the harmonized NSIDC dataset
cat("Loading the harmonized NSIDC dataset...\n")
harmonized_stack <- rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_harmonized_common_dates.tif")

# Load the AMSR dataset
cat("Loading the AMSR dataset...\n")
amsr_overlap <- rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/amsr_common_dates.tif")

# Ensure that the time information is consistent
time(harmonized_stack) <- time(amsr_overlap)

# Recast any values above 1 to 1
harmonized_stack <- clamp(harmonized_stack, lower = 0, upper = 1, values = TRUE)

# Compute statistical metrics
compute_metrics <- function(actual, predicted) {
  actual_values <- values(actual)
  predicted_values <- values(predicted)
  # Remove NA values for accurate comparison
  valid_indices <- !is.na(actual_values) & !is.na(predicted_values)
  actual_values <- actual_values[valid_indices]
  predicted_values <- predicted_values[valid_indices]
  
  rmse <- yardstick::rmse_vec(actual_values, predicted_values)
  r2 <- cor(actual_values, predicted_values)^2
  mase <- yardstick::mase_vec(actual_values, predicted_values)
  ccc <- yardstick::ccc_vec(actual_values, predicted_values)
  huber_loss <- yardstick::huber_loss_vec(actual_values, predicted_values)
  rpiq <- yardstick::rpiq_vec(actual_values, predicted_values)
  rpd <- yardstick::rpd_vec(actual_values, predicted_values)
  smape <- yardstick::smape_vec(actual_values, predicted_values)
  
  return(list(RMSE = rmse, R2 = r2, MASE = mase, CCC = ccc, 
              Huber_Loss = huber_loss, RPIQ = rpiq, RPD = rpd, SMAPE = smape))
}

# Apply metrics to each layer
metrics_list <- lapply(1:nlyr(amsr_overlap), function(i) {
  actual <- amsr_overlap[[i]]
  predicted <- harmonized_stack[[i]]
  compute_metrics(actual, predicted)
})

# Print out metrics for each layer
for (i in 1:length(metrics_list)) {
  cat("Layer", i, ":\n")
  print(metrics_list[[i]])
}

# Extract individual metric values and calculate the averages
rmse_values <- sapply(metrics_list, function(x) x$RMSE)
r2_values <- sapply(metrics_list, function(x) x$R2)
mase_values <- sapply(metrics_list, function(x) x$MASE)
ccc_values <- sapply(metrics_list, function(x) x$CCC)
huber_loss_values <- sapply(metrics_list, function(x) x$Huber_Loss)
rpiq_values <- sapply(metrics_list, function(x) x$RPIQ)
rpd_values <- sapply(metrics_list, function(x) x$RPD)
smape_values <- sapply(metrics_list, function(x) x$SMAPE)

average_rmse <- mean(rmse_values, na.rm = TRUE)
average_r2 <- mean(r2_values, na.rm = TRUE)
average_mase <- mean(mase_values, na.rm = TRUE)
average_ccc <- mean(ccc_values, na.rm = TRUE)
average_huber_loss <- mean(huber_loss_values, na.rm = TRUE)
average_rpiq <- mean(rpiq_values, na.rm = TRUE)
average_rpd <- mean(rpd_values, na.rm = TRUE)
average_smape <- mean(smape_values, na.rm = TRUE)

# Print out average metrics
cat("Average RMSE:", average_rmse, "\n")
cat("Average R2:", average_r2, "\n")
cat("Average MASE:", average_mase, "\n")
cat("Average CCC:", average_ccc, "\n")
cat("Average Huber Loss:", average_huber_loss, "\n")
cat("Average RPIQ:", average_rpiq, "\n")
cat("Average RPD:", average_rpd, "\n")
cat("Average SMAPE:", average_smape, "\n")

# Calculate and print ranges and quartiles for each metric
cat("Calculating and printing ranges and quartiles for each metric...\n")

metrics_summary <- function(metric_values) {
  list(
    Min = min(metric_values, na.rm = TRUE),
    Q1 = quantile(metric_values, 0.25, na.rm = TRUE),
    Median = median(metric_values, na.rm = TRUE),
    Q3 = quantile(metric_values, 0.75, na.rm = TRUE),
    Max = max(metric_values, na.rm = TRUE)
  )
}

metric_names <- c("RMSE", "R2", "MASE", "CCC", "Huber Loss", "RPIQ", "RPD", "SMAPE")
metrics <- list(rmse_values, r2_values, mase_values, ccc_values, huber_loss_values, rpiq_values, rpd_values, smape_values)

for (i in 1:length(metrics)) {
  cat(metric_names[i], ":\n")
  print(metrics_summary(metrics[[i]]))
  cat("\n")
}

# Prepare the data for plotting
data <- data.frame(
  AMSR = as.vector(values(amsr_overlap)),
  NSIDC = as.vector(values(harmonized_stack))
)
data <- na.omit(data)  # Remove rows with NA values

# Generate the hexbin object for the entire dataset
hb <- hexbin(data$AMSR, data$NSIDC, xbins = 35)

# Create the hexbin plot with log10 transformation for the entire dataset (0-1)
plot(hb, 
     main = "Hexbin Plot of AMSR Unified vs. NSIDC Harmonized (0-1 Range)",
     xlab = "AMSR Unified 12.5 km (Actual, 0-1)",
     ylab = "NSIDC 12.5 km Harmonized (Predicted, 0-1)",
     colramp = function(n) viridis::viridis(n),
     colorcut = seq(0, 1, length.out = 10), 
     mincnt = 1,   # Minimum count threshold
     trans = log10,  # Log10 transformation for counts
     inv = function(x) 10^x)  # Inverse transformation

# Generate the hexbin object for the entire dataset
hb <- hexbin(data$AMSR, data$NSIDC, xbins = 45)

# Create the hexbin plot with log10 transformation for the entire dataset (0-1)
plot(hb, 
     main = "Hexbin Plot of AMSR Unified vs. NSIDC Harmonized (0-1 Range)",
     xlab = "AMSR Unified 12.5 km (Actual, 0-1)",
     ylab = "NSIDC 12.5 km Harmonized (Predicted, 0-1)",
     colramp = function(n) viridis::viridis(n),
     colorcut = seq(0, 1, length.out = 7), 
     mincnt = 1,   # Minimum count threshold
     trans = log10,  # Log10 transformation for counts
     inv = function(x) 10^x)  # Inverse transformation






# Load necessary libraries
library(ggplot2)
library(RColorBrewer)
library(dplyr)

# Create binned categories for AMSR and NSIDC
data$AMSR_bin <- cut(data$AMSR, breaks = seq(0, 1, by = 0.1), include.lowest = TRUE)
data$NSIDC_bin <- cut(data$NSIDC, breaks = seq(0, 1, by = 0.1), include.lowest = TRUE)

# Function to calculate SMAPE
calc_smape <- function(actual, predicted) {
  return(100 * mean(abs(actual - predicted) / ((abs(actual) + abs(predicted)) / 2)))
}

# Aggregate data to calculate mean SMAPE for each bin combination
error_data <- data %>%
  group_by(AMSR_bin, NSIDC_bin) %>%
  summarize(
    Mean_SMAPE = calc_smape(AMSR, NSIDC),  # Mean SMAPE for each bin
    Count = n()                            # Number of points in the bin
  ) %>%
  na.omit()

# Calculate the relative contribution of each bin to the total SMAPE
total_smape_sum <- sum(error_data$Mean_SMAPE * error_data$Count)
error_data <- error_data %>%
  mutate(Relative_Error_Contribution = (Mean_SMAPE * Count / total_smape_sum) * 100)

# Plot the heatmap of relative error contribution using Brewer Blues
ggplot(error_data, aes(x = AMSR_bin, y = NSIDC_bin, fill = Relative_Error_Contribution)) +
  geom_tile() +
  scale_fill_distiller(palette = "Blues", name = "Relative Error (%)") +
  labs(
    title = "Relative Error Contribution by Binned AMSR and NSIDC Values",
    x = "Binned AMSR (0-1)",
    y = "Binned NSIDC (0-1)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))




```





```{r}
# Load necessary libraries
library(ggplot2)

# Plot histogram for AMSR dataset
ggplot(data, aes(x = AMSR)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue", color = "black", alpha = 0.7) +
  labs(
    title = "Histogram of AMSR Data",
    x = "AMSR Values (0-1)",
    y = "Count"
  ) +
  theme_minimal()

# Plot histogram for NSIDC dataset
ggplot(data, aes(x = NSIDC)) +
  geom_histogram(binwidth = 0.05, fill = "darkorange", color = "black", alpha = 0.7) +
  labs(
    title = "Histogram of NSIDC Data",
    x = "NSIDC Values (0-1)",
    y = "Count"
  ) +
  theme_minimal()




# Sort the heatmap data by SMAPE in descending order
top_errors <- heatmap_data %>%
  arrange(desc(SMAPE)) %>%
  head(10)  # Modify '10' to the number of top bins you want to examine

# View the top bins contributing the most error
print(top_errors)

# Calculate total or average SMAPE for specific binned ranges if needed:
# For example, summarizing error for AMSR values between 0.0 and 0.2
summary_error <- heatmap_data %>%
  filter(AMSR_bin %in% c("(0,0.05]", "(0.05,0.1]", "(0.1,0.15]", "(0.15,0.2]")) %>%
  summarize(Total_Error = sum(SMAPE), Avg_Error = mean(SMAPE))

print(summary_error)

```



```{r}
# Set the custom color palette
pal <- c("#bb3e03","#ee9b00","#e9d8a6","#94d2bd","#0a9396","#005f73")
bck <- "#001219"

# Set the background color
par(bg = bck)

# Generate the hexbin object for the entire dataset
hb <- hexbin(data$AMSR, data$NSIDC, xbins = 30)

# Determine appropriate breaks based on your data
custom_breaks <- c(0, 100, 1000, 10000, 50000, 100000, 500000, 1e6, 5e6, max(hb@count))

# Normalize custom breaks to be in the range [0, 1]
colorcut_breaks <- custom_breaks / max(hb@count)

# Ensure the breaks start at 0 and end at 1
colorcut_breaks <- c(0, colorcut_breaks[colorcut_breaks > 0 & colorcut_breaks < 1], 1)

# Create the hexbin plot with the custom color palette
plot(hb, 
     main = "Hexbin Plot of AMSR Unified vs. NSIDC Harmonized (0-1 Range)",
     xlab = "AMSR Unified 12.5 km (Actual, 0-1)",
     ylab = "NSIDC 12.5 km Harmonized (Predicted, 0-1)",
     colramp = function(n) colorRampPalette(pal)(n),  # Use the custom color palette
     colorcut = colorcut_breaks,  # Use the corrected breaks
     mincnt = 1)  # Minimum count threshold





# Load the necessary libraries
library(terra)

# Load the harmonized NSIDC dataset
harmonized_stack <- rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/nsidc_harmonized_common_dates.tif")

# Load the AMSR dataset
amsr_overlap <- rast("D:/Manuscripts_localData/FrostBound_AQ/Datasets/dataset-harmonization/harmonized-dataset-comparison/amsr_common_dates.tif")

# Calculate the number of pixels in each dataset
n_pixels_harmonized <- ncell(harmonized_stack)
n_pixels_amsr <- ncell(amsr_overlap)

# Print the number of pixels
cat("Number of pixels in the harmonized NSIDC dataset:", n_pixels_harmonized, "\n")
cat("Number of pixels in the AMSR dataset:", n_pixels_amsr, "\n")





# Generate the hexbin object for the entire dataset
hb <- hexbin(data$AMSR, data$NSIDC, xbins = 10)

# Calculate quantile-based breaks
quantile_breaks <- quantile(hb@count, probs = seq(0, 1, length.out = 7), na.rm = TRUE)

# Ensure colorcut includes 0 and 1
colorcut_breaks <- c(0, quantile_breaks[-1] / max(hb@count))

# Create the hexbin plot using quantile-based legend breaks
plot(hb, 
     main = "Hexbin Plot of AMSR Unified vs. NSIDC Harmonized (0-1 Range)",
     xlab = "AMSR Unified 12.5 km (Actual, 0-1)",
     ylab = "NSIDC 12.5 km Harmonized (Predicted, 0-1)",
     colramp = function(n) pal,
     colorcut = colorcut_breaks,  # Use quantile-based breaks including 0
     mincnt = 1   # Minimum count threshold
)





# Generate the hexbin object for the entire dataset
hb <- hexbin(data$AMSR, data$NSIDC, xbins = 50)

# Calculate total number of pairs
total_pairs <- sum(hb@count)

# Convert counts to percentages
hb@count <- (hb@count / total_pairs) * 100

# Manually set breaks for percentage-based legend
manual_breaks <- c(0, 1, 5, 10, 25, 50, 100)  # Adjust these values as needed

# Normalize the breaks to range from 0 to 1 for colorcut
colorcut <- manual_breaks / max(manual_breaks)

# Create the hexbin plot using the percentage-based counts
plot(hb, 
     main = "Hexbin Plot of AMSR Unified vs. NSIDC Harmonized (0-1 Range)",
     xlab = "AMSR Unified 12.5 km (Actual, 0-1)",
     ylab = "NSIDC 12.5 km Harmonized (Predicted, 0-1)",
     colramp = function(n) pal,  # Using your custom color palette
     colorcut = colorcut,  # Use manual breaks for better distribution
     mincnt = 1   # Minimum count threshold
)


```

